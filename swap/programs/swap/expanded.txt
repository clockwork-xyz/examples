#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod id {
    use anchor_lang::prelude::*;
    /// The static program ID
    pub static ID: anchor_lang::solana_program::pubkey::Pubkey = anchor_lang::solana_program::pubkey::Pubkey::new_from_array([
        203u8,
        164u8,
        28u8,
        135u8,
        0u8,
        1u8,
        232u8,
        149u8,
        203u8,
        191u8,
        21u8,
        105u8,
        222u8,
        161u8,
        224u8,
        212u8,
        2u8,
        117u8,
        139u8,
        164u8,
        173u8,
        157u8,
        1u8,
        135u8,
        10u8,
        213u8,
        82u8,
        19u8,
        233u8,
        239u8,
        187u8,
        15u8,
    ]);
    /// Confirms that a given pubkey is equivalent to the program ID
    pub fn check_id(id: &anchor_lang::solana_program::pubkey::Pubkey) -> bool {
        id == &ID
    }
    /// Returns the program ID
    pub fn id() -> anchor_lang::solana_program::pubkey::Pubkey {
        ID
    }
}
mod instructions {
    pub mod orca_whirlpool_swap {
        use {
            anchor_lang::{prelude::*, solana_program::system_program, InstructionData},
            anchor_spl::token::{transfer, Mint, Token, TokenAccount, Transfer},
            clockwork_sdk::state::{Thread, ThreadAccount, ThreadResponse},
            whirlpool::utils::get_tick_array_pubkeys,
        };
        #[instruction(amount:u64, a_to_b:bool)]
        pub struct OrcaWhirlpoolSwap<'info> {
            /// CHECK:
            pub a_mint: Box<Account<'info, Mint>>,
            /// CHECK:
            pub b_mint: Box<Account<'info, Mint>>,
            #[account(
                mut,
                associated_token::mint = a_mint,
                associated_token::authority = swap_thread.authority
            )]
            pub authority_a_vault: Box<Account<'info, TokenAccount>>,
            #[account(
                mut,
                associated_token::mint = b_mint,
                associated_token::authority = swap_thread.authority
            )]
            pub authority_b_vault: Box<Account<'info, TokenAccount>>,
            #[account(
                mut,
                associated_token::authority = swap_thread,
                associated_token::mint = a_mint,
            )]
            pub swap_thread_a_vault: Box<Account<'info, TokenAccount>>,
            #[account(
                mut,
                associated_token::authority = swap_thread,
                associated_token::mint = b_mint,
            )]
            pub swap_thread_b_vault: Box<Account<'info, TokenAccount>>,
            #[account(
                signer,
                address = swap_thread.pubkey(),
                constraint = swap_thread.authority = = authority_a_vault.owner
            )]
            pub swap_thread: Box<Account<'info, Thread>>,
            /// CHECK:
            pub oracle: AccountInfo<'info>,
            /// CHECK:
            pub orca_whirlpool_program: AccountInfo<'info>,
            #[account(address = system_program::ID)]
            pub system_program: Program<'info, System>,
            #[account(address = anchor_spl::token::ID)]
            pub token_program: Program<'info, Token>,
            /// CHECK:
            #[account(mut)]
            pub whirlpool: AccountInfo<'info>,
            /// CHECK:
            #[account(mut)]
            pub whirlpool_token_a_vault: AccountInfo<'info>,
            /// CHECK:
            #[account(mut)]
            pub whirlpool_token_b_vault: AccountInfo<'info>,
        }
        #[automatically_derived]
        impl<'info> anchor_lang::Accounts<'info> for OrcaWhirlpoolSwap<'info>
        where
            'info: 'info,
        {
            #[inline(never)]
            fn try_accounts(
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
                accounts: &mut &[anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >],
                ix_data: &[u8],
                __bumps: &mut std::collections::BTreeMap<String, u8>,
                __reallocs: &mut std::collections::BTreeSet<
                    anchor_lang::solana_program::pubkey::Pubkey,
                >,
            ) -> anchor_lang::Result<Self> {
                let mut ix_data = ix_data;
                struct __Args {
                    amount: u64,
                    a_to_b: bool,
                }
                impl borsh::ser::BorshSerialize for __Args
                where
                    u64: borsh::ser::BorshSerialize,
                    bool: borsh::ser::BorshSerialize,
                {
                    fn serialize<W: borsh::maybestd::io::Write>(
                        &self,
                        writer: &mut W,
                    ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                        borsh::BorshSerialize::serialize(&self.amount, writer)?;
                        borsh::BorshSerialize::serialize(&self.a_to_b, writer)?;
                        Ok(())
                    }
                }
                impl borsh::de::BorshDeserialize for __Args
                where
                    u64: borsh::BorshDeserialize,
                    bool: borsh::BorshDeserialize,
                {
                    fn deserialize(
                        buf: &mut &[u8],
                    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
                        Ok(Self {
                            amount: borsh::BorshDeserialize::deserialize(buf)?,
                            a_to_b: borsh::BorshDeserialize::deserialize(buf)?,
                        })
                    }
                }
                let __Args { amount, a_to_b } = __Args::deserialize(&mut ix_data)
                    .map_err(|_| {
                        anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                    })?;
                let a_mint: Box<anchor_lang::accounts::account::Account<Mint>> = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("a_mint"))?;
                let b_mint: Box<anchor_lang::accounts::account::Account<Mint>> = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("b_mint"))?;
                let authority_a_vault: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority_a_vault"))?;
                let authority_b_vault: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("authority_b_vault"))?;
                let swap_thread_a_vault: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("swap_thread_a_vault"))?;
                let swap_thread_b_vault: Box<
                    anchor_lang::accounts::account::Account<TokenAccount>,
                > = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("swap_thread_b_vault"))?;
                let swap_thread: Box<anchor_lang::accounts::account::Account<Thread>> = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("swap_thread"))?;
                let oracle: AccountInfo = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("oracle"))?;
                let orca_whirlpool_program: AccountInfo = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("orca_whirlpool_program"))?;
                let system_program: anchor_lang::accounts::program::Program<System> = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("system_program"))?;
                let token_program: anchor_lang::accounts::program::Program<Token> = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("token_program"))?;
                let whirlpool: AccountInfo = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("whirlpool"))?;
                let whirlpool_token_a_vault: AccountInfo = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("whirlpool_token_a_vault"))?;
                let whirlpool_token_b_vault: AccountInfo = anchor_lang::Accounts::try_accounts(
                        program_id,
                        accounts,
                        ix_data,
                        __bumps,
                        __reallocs,
                    )
                    .map_err(|e| e.with_account_name("whirlpool_token_b_vault"))?;
                {
                    let my_owner = authority_a_vault.owner;
                    let wallet_address = swap_thread.authority.key();
                    if my_owner != wallet_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                )
                                .with_account_name("authority_a_vault")
                                .with_pubkeys((my_owner, wallet_address)),
                        );
                    }
                    let __associated_token_address = anchor_spl::associated_token::get_associated_token_address(
                        &wallet_address,
                        &a_mint.key(),
                    );
                    let my_key = authority_a_vault.key();
                    if my_key != __associated_token_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAssociated,
                                )
                                .with_account_name("authority_a_vault")
                                .with_pubkeys((my_key, __associated_token_address)),
                        );
                    }
                }
                if !authority_a_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("authority_a_vault"),
                    );
                }
                {
                    let my_owner = authority_b_vault.owner;
                    let wallet_address = swap_thread.authority.key();
                    if my_owner != wallet_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                )
                                .with_account_name("authority_b_vault")
                                .with_pubkeys((my_owner, wallet_address)),
                        );
                    }
                    let __associated_token_address = anchor_spl::associated_token::get_associated_token_address(
                        &wallet_address,
                        &b_mint.key(),
                    );
                    let my_key = authority_b_vault.key();
                    if my_key != __associated_token_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAssociated,
                                )
                                .with_account_name("authority_b_vault")
                                .with_pubkeys((my_key, __associated_token_address)),
                        );
                    }
                }
                if !authority_b_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("authority_b_vault"),
                    );
                }
                {
                    let my_owner = swap_thread_a_vault.owner;
                    let wallet_address = swap_thread.key();
                    if my_owner != wallet_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                )
                                .with_account_name("swap_thread_a_vault")
                                .with_pubkeys((my_owner, wallet_address)),
                        );
                    }
                    let __associated_token_address = anchor_spl::associated_token::get_associated_token_address(
                        &wallet_address,
                        &a_mint.key(),
                    );
                    let my_key = swap_thread_a_vault.key();
                    if my_key != __associated_token_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAssociated,
                                )
                                .with_account_name("swap_thread_a_vault")
                                .with_pubkeys((my_key, __associated_token_address)),
                        );
                    }
                }
                if !swap_thread_a_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("swap_thread_a_vault"),
                    );
                }
                {
                    let my_owner = swap_thread_b_vault.owner;
                    let wallet_address = swap_thread.key();
                    if my_owner != wallet_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintTokenOwner,
                                )
                                .with_account_name("swap_thread_b_vault")
                                .with_pubkeys((my_owner, wallet_address)),
                        );
                    }
                    let __associated_token_address = anchor_spl::associated_token::get_associated_token_address(
                        &wallet_address,
                        &b_mint.key(),
                    );
                    let my_key = swap_thread_b_vault.key();
                    if my_key != __associated_token_address {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAssociated,
                                )
                                .with_account_name("swap_thread_b_vault")
                                .with_pubkeys((my_key, __associated_token_address)),
                        );
                    }
                }
                if !swap_thread_b_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("swap_thread_b_vault"),
                    );
                }
                if !swap_thread.to_account_info().is_signer {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintSigner,
                            )
                            .with_account_name("swap_thread"),
                    );
                }
                if !(swap_thread.authority == authority_a_vault.owner) {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintRaw,
                            )
                            .with_account_name("swap_thread"),
                    );
                }
                {
                    let actual = swap_thread.key();
                    let expected = swap_thread.pubkey();
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("swap_thread")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let actual = system_program.key();
                    let expected = system_program::ID;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("system_program")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                {
                    let actual = token_program.key();
                    let expected = anchor_spl::token::ID;
                    if actual != expected {
                        return Err(
                            anchor_lang::error::Error::from(
                                    anchor_lang::error::ErrorCode::ConstraintAddress,
                                )
                                .with_account_name("token_program")
                                .with_pubkeys((actual, expected)),
                        );
                    }
                }
                if !whirlpool.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("whirlpool"),
                    );
                }
                if !whirlpool_token_a_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("whirlpool_token_a_vault"),
                    );
                }
                if !whirlpool_token_b_vault.to_account_info().is_writable {
                    return Err(
                        anchor_lang::error::Error::from(
                                anchor_lang::error::ErrorCode::ConstraintMut,
                            )
                            .with_account_name("whirlpool_token_b_vault"),
                    );
                }
                Ok(OrcaWhirlpoolSwap {
                    a_mint,
                    b_mint,
                    authority_a_vault,
                    authority_b_vault,
                    swap_thread_a_vault,
                    swap_thread_b_vault,
                    swap_thread,
                    oracle,
                    orca_whirlpool_program,
                    system_program,
                    token_program,
                    whirlpool,
                    whirlpool_token_a_vault,
                    whirlpool_token_b_vault,
                })
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountInfos<'info> for OrcaWhirlpoolSwap<'info>
        where
            'info: 'info,
        {
            fn to_account_infos(
                &self,
            ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                let mut account_infos = ::alloc::vec::Vec::new();
                account_infos.extend(self.a_mint.to_account_infos());
                account_infos.extend(self.b_mint.to_account_infos());
                account_infos.extend(self.authority_a_vault.to_account_infos());
                account_infos.extend(self.authority_b_vault.to_account_infos());
                account_infos.extend(self.swap_thread_a_vault.to_account_infos());
                account_infos.extend(self.swap_thread_b_vault.to_account_infos());
                account_infos.extend(self.swap_thread.to_account_infos());
                account_infos.extend(self.oracle.to_account_infos());
                account_infos.extend(self.orca_whirlpool_program.to_account_infos());
                account_infos.extend(self.system_program.to_account_infos());
                account_infos.extend(self.token_program.to_account_infos());
                account_infos.extend(self.whirlpool.to_account_infos());
                account_infos.extend(self.whirlpool_token_a_vault.to_account_infos());
                account_infos.extend(self.whirlpool_token_b_vault.to_account_infos());
                account_infos
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::ToAccountMetas for OrcaWhirlpoolSwap<'info> {
            fn to_account_metas(
                &self,
                is_signer: Option<bool>,
            ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                let mut account_metas = ::alloc::vec::Vec::new();
                account_metas.extend(self.a_mint.to_account_metas(None));
                account_metas.extend(self.b_mint.to_account_metas(None));
                account_metas.extend(self.authority_a_vault.to_account_metas(None));
                account_metas.extend(self.authority_b_vault.to_account_metas(None));
                account_metas.extend(self.swap_thread_a_vault.to_account_metas(None));
                account_metas.extend(self.swap_thread_b_vault.to_account_metas(None));
                account_metas.extend(self.swap_thread.to_account_metas(Some(true)));
                account_metas.extend(self.oracle.to_account_metas(None));
                account_metas.extend(self.orca_whirlpool_program.to_account_metas(None));
                account_metas.extend(self.system_program.to_account_metas(None));
                account_metas.extend(self.token_program.to_account_metas(None));
                account_metas.extend(self.whirlpool.to_account_metas(None));
                account_metas
                    .extend(self.whirlpool_token_a_vault.to_account_metas(None));
                account_metas
                    .extend(self.whirlpool_token_b_vault.to_account_metas(None));
                account_metas
            }
        }
        #[automatically_derived]
        impl<'info> anchor_lang::AccountsExit<'info> for OrcaWhirlpoolSwap<'info>
        where
            'info: 'info,
        {
            fn exit(
                &self,
                program_id: &anchor_lang::solana_program::pubkey::Pubkey,
            ) -> anchor_lang::Result<()> {
                anchor_lang::AccountsExit::exit(&self.authority_a_vault, program_id)
                    .map_err(|e| e.with_account_name("authority_a_vault"))?;
                anchor_lang::AccountsExit::exit(&self.authority_b_vault, program_id)
                    .map_err(|e| e.with_account_name("authority_b_vault"))?;
                anchor_lang::AccountsExit::exit(&self.swap_thread_a_vault, program_id)
                    .map_err(|e| e.with_account_name("swap_thread_a_vault"))?;
                anchor_lang::AccountsExit::exit(&self.swap_thread_b_vault, program_id)
                    .map_err(|e| e.with_account_name("swap_thread_b_vault"))?;
                anchor_lang::AccountsExit::exit(&self.whirlpool, program_id)
                    .map_err(|e| e.with_account_name("whirlpool"))?;
                anchor_lang::AccountsExit::exit(
                        &self.whirlpool_token_a_vault,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("whirlpool_token_a_vault"))?;
                anchor_lang::AccountsExit::exit(
                        &self.whirlpool_token_b_vault,
                        program_id,
                    )
                    .map_err(|e| e.with_account_name("whirlpool_token_b_vault"))?;
                Ok(())
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is a Pubkey,
        /// instead of an `AccountInfo`. This is useful for clients that want
        /// to generate a list of accounts, without explicitly knowing the
        /// order all the fields should be in.
        ///
        /// To access the struct in this module, one should use the sibling
        /// `accounts` module (also generated), which re-exports this.
        pub(crate) mod __client_accounts_orca_whirlpool_swap {
            use super::*;
            use anchor_lang::prelude::borsh;
            /// Generated client accounts for [`OrcaWhirlpoolSwap`].
            pub struct OrcaWhirlpoolSwap {
                pub a_mint: anchor_lang::solana_program::pubkey::Pubkey,
                pub b_mint: anchor_lang::solana_program::pubkey::Pubkey,
                pub authority_a_vault: anchor_lang::solana_program::pubkey::Pubkey,
                pub authority_b_vault: anchor_lang::solana_program::pubkey::Pubkey,
                pub swap_thread_a_vault: anchor_lang::solana_program::pubkey::Pubkey,
                pub swap_thread_b_vault: anchor_lang::solana_program::pubkey::Pubkey,
                pub swap_thread: anchor_lang::solana_program::pubkey::Pubkey,
                pub oracle: anchor_lang::solana_program::pubkey::Pubkey,
                pub orca_whirlpool_program: anchor_lang::solana_program::pubkey::Pubkey,
                pub system_program: anchor_lang::solana_program::pubkey::Pubkey,
                pub token_program: anchor_lang::solana_program::pubkey::Pubkey,
                pub whirlpool: anchor_lang::solana_program::pubkey::Pubkey,
                pub whirlpool_token_a_vault: anchor_lang::solana_program::pubkey::Pubkey,
                pub whirlpool_token_b_vault: anchor_lang::solana_program::pubkey::Pubkey,
            }
            impl borsh::ser::BorshSerialize for OrcaWhirlpoolSwap
            where
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
                anchor_lang::solana_program::pubkey::Pubkey: borsh::ser::BorshSerialize,
            {
                fn serialize<W: borsh::maybestd::io::Write>(
                    &self,
                    writer: &mut W,
                ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
                    borsh::BorshSerialize::serialize(&self.a_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.b_mint, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority_a_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.authority_b_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.swap_thread_a_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.swap_thread_b_vault, writer)?;
                    borsh::BorshSerialize::serialize(&self.swap_thread, writer)?;
                    borsh::BorshSerialize::serialize(&self.oracle, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.orca_whirlpool_program,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(&self.system_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.token_program, writer)?;
                    borsh::BorshSerialize::serialize(&self.whirlpool, writer)?;
                    borsh::BorshSerialize::serialize(
                        &self.whirlpool_token_a_vault,
                        writer,
                    )?;
                    borsh::BorshSerialize::serialize(
                        &self.whirlpool_token_b_vault,
                        writer,
                    )?;
                    Ok(())
                }
            }
            #[automatically_derived]
            impl anchor_lang::ToAccountMetas for OrcaWhirlpoolSwap {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.a_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.b_mint,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.authority_a_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.authority_b_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.swap_thread_a_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.swap_thread_b_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.swap_thread,
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.oracle,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.orca_whirlpool_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.system_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                self.token_program,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.whirlpool,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.whirlpool_token_a_vault,
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                self.whirlpool_token_b_vault,
                                false,
                            ),
                        );
                    account_metas
                }
            }
        }
        /// An internal, Anchor generated module. This is used (as an
        /// implementation detail), to generate a CPI struct for a given
        /// `#[derive(Accounts)]` implementation, where each field is an
        /// AccountInfo.
        ///
        /// To access the struct in this module, one should use the sibling
        /// [`cpi::accounts`] module (also generated), which re-exports this.
        pub(crate) mod __cpi_client_accounts_orca_whirlpool_swap {
            use super::*;
            /// Generated CPI struct of the accounts for [`OrcaWhirlpoolSwap`].
            pub struct OrcaWhirlpoolSwap<'info> {
                pub a_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub b_mint: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority_a_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub authority_b_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub swap_thread_a_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub swap_thread_b_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub swap_thread: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub oracle: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub orca_whirlpool_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub system_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub token_program: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub whirlpool: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub whirlpool_token_a_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
                pub whirlpool_token_b_vault: anchor_lang::solana_program::account_info::AccountInfo<
                    'info,
                >,
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountMetas for OrcaWhirlpoolSwap<'info> {
                fn to_account_metas(
                    &self,
                    is_signer: Option<bool>,
                ) -> Vec<anchor_lang::solana_program::instruction::AccountMeta> {
                    let mut account_metas = ::alloc::vec::Vec::new();
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.a_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.b_mint),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.authority_a_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.authority_b_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.swap_thread_a_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.swap_thread_b_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.swap_thread),
                                true,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.oracle),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.orca_whirlpool_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.system_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new_readonly(
                                anchor_lang::Key::key(&self.token_program),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.whirlpool),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.whirlpool_token_a_vault),
                                false,
                            ),
                        );
                    account_metas
                        .push(
                            anchor_lang::solana_program::instruction::AccountMeta::new(
                                anchor_lang::Key::key(&self.whirlpool_token_b_vault),
                                false,
                            ),
                        );
                    account_metas
                }
            }
            #[automatically_derived]
            impl<'info> anchor_lang::ToAccountInfos<'info> for OrcaWhirlpoolSwap<'info> {
                fn to_account_infos(
                    &self,
                ) -> Vec<anchor_lang::solana_program::account_info::AccountInfo<'info>> {
                    let mut account_infos = ::alloc::vec::Vec::new();
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.a_mint),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.b_mint),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority_a_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.authority_b_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.swap_thread_a_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.swap_thread_b_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.swap_thread,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(&self.oracle),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.orca_whirlpool_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.system_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.token_program,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.whirlpool,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.whirlpool_token_a_vault,
                            ),
                        );
                    account_infos
                        .extend(
                            anchor_lang::ToAccountInfos::to_account_infos(
                                &self.whirlpool_token_b_vault,
                            ),
                        );
                    account_infos
                }
            }
        }
        pub fn handler<'info>(
            ctx: Context<'_, '_, '_, 'info, OrcaWhirlpoolSwap<'info>>,
            amount: u64,
            a_to_b: bool,
        ) -> Result<ThreadResponse> {
            let authority_a_vault = &mut ctx.accounts.authority_a_vault;
            let authority_b_vault = &mut ctx.accounts.authority_b_vault;
            let swap_thread_a_vault = &mut ctx.accounts.swap_thread_a_vault;
            let swap_thread_b_vault = &mut ctx.accounts.swap_thread_b_vault;
            let swap_thread = &ctx.accounts.swap_thread;
            let oracle = &ctx.accounts.oracle;
            let orca_whirlpool_program = &ctx.accounts.orca_whirlpool_program;
            let token_program = &ctx.accounts.token_program;
            let whirlpool = &mut ctx.accounts.whirlpool;
            let whirlpool_token_a_vault = &mut ctx.accounts.whirlpool_token_a_vault;
            let whirlpool_token_b_vault = &mut ctx.accounts.whirlpool_token_b_vault;
            let tick_array0 = ctx.remaining_accounts.get(0).unwrap();
            let tick_array1 = ctx.remaining_accounts.get(1).unwrap();
            let tick_array2 = ctx.remaining_accounts.get(2).unwrap();
            let whirlpool_data = whirlpool.try_borrow_data().unwrap().to_owned();
            let whirlpool_state = whirlpool::state::Whirlpool::try_deserialize(
                    &mut whirlpool_data.as_slice(),
                )
                .unwrap();
            let tick_array_pubkeys = get_tick_array_pubkeys(
                whirlpool_state.tick_current_index,
                whirlpool_state.tick_spacing,
                a_to_b,
                &whirlpool::ID,
                &whirlpool.key(),
            );
            transfer(
                CpiContext::new(
                    token_program.to_account_info(),
                    Transfer {
                        from: if a_to_b {
                            authority_a_vault.to_account_info()
                        } else {
                            authority_b_vault.to_account_info()
                        },
                        to: if a_to_b {
                            swap_thread_a_vault.to_account_info()
                        } else {
                            swap_thread_b_vault.to_account_info()
                        },
                        authority: swap_thread.to_account_info(),
                    },
                ),
                amount,
            )?;
            whirlpool::cpi::swap(
                CpiContext::new(
                    orca_whirlpool_program.to_account_info(),
                    whirlpool::cpi::accounts::Swap {
                        token_program: token_program.to_account_info(),
                        token_authority: swap_thread.to_account_info(),
                        whirlpool: whirlpool.to_account_info(),
                        token_owner_account_a: swap_thread_a_vault.to_account_info(),
                        token_vault_a: whirlpool_token_a_vault.to_account_info(),
                        token_owner_account_b: swap_thread_b_vault.to_account_info(),
                        token_vault_b: whirlpool_token_b_vault.to_account_info(),
                        tick_array0: tick_array0.to_account_info(),
                        tick_array1: tick_array1.to_account_info(),
                        tick_array2: tick_array2.to_account_info(),
                        oracle: oracle.to_account_info(),
                    },
                ),
                amount,
                0,
                whirlpool_state.sqrt_price,
                false,
                a_to_b,
            )?;
            if a_to_b {
                swap_thread_b_vault.reload()?
            } else {
                swap_thread_a_vault.reload()?
            }
            transfer(
                CpiContext::new(
                    token_program.to_account_info(),
                    Transfer {
                        from: if a_to_b {
                            swap_thread_b_vault.to_account_info()
                        } else {
                            swap_thread_a_vault.to_account_info()
                        },
                        to: if a_to_b {
                            authority_b_vault.to_account_info()
                        } else {
                            authority_a_vault.to_account_info()
                        },
                        authority: swap_thread.to_account_info(),
                    },
                ),
                swap_thread_b_vault.amount,
            )?;
            Ok(ThreadResponse {
                kickoff_instruction: Some(clockwork_sdk::state::InstructionData {
                    program_id: crate::ID,
                    accounts: [
                        crate::accounts::OrcaWhirlpoolSwap {
                            a_mint: ctx.accounts.a_mint.key(),
                            b_mint: ctx.accounts.b_mint.key(),
                            authority_a_vault: ctx.accounts.authority_a_vault.key(),
                            authority_b_vault: ctx.accounts.authority_b_vault.key(),
                            swap_thread: ctx.accounts.swap_thread.key(),
                            swap_thread_a_vault: ctx.accounts.swap_thread_a_vault.key(),
                            swap_thread_b_vault: ctx.accounts.swap_thread_b_vault.key(),
                            oracle: ctx.accounts.oracle.key(),
                            system_program: ctx.accounts.system_program.key(),
                            token_program: ctx.accounts.token_program.key(),
                            whirlpool: ctx.accounts.whirlpool.key(),
                            orca_whirlpool_program: whirlpool::ID,
                            whirlpool_token_a_vault: whirlpool_state.token_vault_a,
                            whirlpool_token_b_vault: whirlpool_state.token_vault_b,
                        }
                            .to_account_metas(Some(true)),
                        tick_array_pubkeys
                            .iter()
                            .map(|pk| AccountMeta::new(*pk, false))
                            .collect::<Vec<AccountMeta>>(),
                    ]
                        .concat(),
                    data: crate::instruction::OrcaWhirlpoolSwap {
                        amount: 10_000_000_000,
                        a_to_b: true,
                    }
                        .data(),
                }),
                next_instruction: None,
            })
        }
    }
    pub use orca_whirlpool_swap::*;
}
pub use id::ID;
use anchor_lang::prelude::*;
use instructions::*;
use self::swap::*;
/// The Anchor codegen exposes a programming model where a user defines
/// a set of methods inside of a `#[program]` module in a way similar
/// to writing RPC request handlers. The macro then generates a bunch of
/// code wrapping these user defined methods into something that can be
/// executed on Solana.
///
/// These methods fall into one of three categories, each of which
/// can be considered a different "namespace" of the program.
///
/// 1) Global methods - regular methods inside of the `#[program]`.
/// 2) State methods - associated methods inside a `#[state]` struct.
/// 3) Interface methods - methods inside a strait struct's
///    implementation of an `#[interface]` trait.
///
/// Care must be taken by the codegen to prevent collisions between
/// methods in these different namespaces. For this reason, Anchor uses
/// a variant of sighash to perform method dispatch, rather than
/// something like a simple enum variant discriminator.
///
/// The execution flow of the generated code can be roughly outlined:
///
/// * Start program via the entrypoint.
/// * Strip method identifier off the first 8 bytes of the instruction
///   data and invoke the identified method. The method identifier
///   is a variant of sighash. See docs.rs for `anchor_lang` for details.
/// * If the method identifier is an IDL identifier, execute the IDL
///   instructions, which are a special set of hardcoded instructions
///   baked into every Anchor program. Then exit.
/// * Otherwise, the method identifier is for a user defined
///   instruction, i.e., one of the methods in the user defined
///   `#[program]` module. Perform method dispatch, i.e., execute the
///   big match statement mapping method identifier to method handler
///   wrapper.
/// * Run the method handler wrapper. This wraps the code the user
///   actually wrote, deserializing the accounts, constructing the
///   context, invoking the user's code, and finally running the exit
///   routine, which typically persists account changes.
///
/// The `entry` function here, defines the standard entry to a Solana
/// program, where execution begins.
pub fn entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::solana_program::entrypoint::ProgramResult {
    try_entry(program_id, accounts, data)
        .map_err(|e| {
            e.log();
            e.into()
        })
}
fn try_entry(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::Result<()> {
    if *program_id != ID {
        return Err(anchor_lang::error::ErrorCode::DeclaredProgramIdMismatch.into());
    }
    if data.len() < 8 {
        return Err(anchor_lang::error::ErrorCode::InstructionMissing.into());
    }
    dispatch(program_id, accounts, data)
}
/// Module representing the program.
pub mod program {
    use super::*;
    /// Type representing the program.
    pub struct Swap;
    #[automatically_derived]
    impl ::core::clone::Clone for Swap {
        #[inline]
        fn clone(&self) -> Swap {
            Swap
        }
    }
    impl anchor_lang::Id for Swap {
        fn id() -> Pubkey {
            ID
        }
    }
}
/// Performs method dispatch.
///
/// Each method in an anchor program is uniquely defined by a namespace
/// and a rust identifier (i.e., the name given to the method). These
/// two pieces can be combined to creater a method identifier,
/// specifically, Anchor uses
///
/// Sha256("<namespace>:<rust-identifier>")[..8],
///
/// where the namespace can be one of three types. 1) "global" for a
/// regular instruction, 2) "state" for a state struct instruction
/// handler and 3) a trait namespace (used in combination with the
/// `#[interface]` attribute), which is defined by the trait name, e..
/// `MyTrait`.
///
/// With this 8 byte identifier, Anchor performs method dispatch,
/// matching the given 8 byte identifier to the associated method
/// handler, which leads to user defined code being eventually invoked.
fn dispatch(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    data: &[u8],
) -> anchor_lang::Result<()> {
    let mut ix_data: &[u8] = data;
    let sighash: [u8; 8] = {
        let mut sighash: [u8; 8] = [0; 8];
        sighash.copy_from_slice(&ix_data[..8]);
        ix_data = &ix_data[8..];
        sighash
    };
    if true {
        if sighash == anchor_lang::idl::IDL_IX_TAG.to_le_bytes() {
            return __private::__idl::__idl_dispatch(program_id, accounts, &ix_data);
        }
    }
    use anchor_lang::Discriminator;
    match sighash {
        instruction::OrcaWhirlpoolSwap::DISCRIMINATOR => {
            __private::__global::orca_whirlpool_swap(program_id, accounts, ix_data)
        }
        _ => Err(anchor_lang::error::ErrorCode::InstructionFallbackNotFound.into()),
    }
}
/// Create a private module to not clutter the program's namespace.
/// Defines an entrypoint for each individual instruction handler
/// wrapper.
mod __private {
    use super::*;
    /// __idl mod defines handlers for injected Anchor IDL instructions.
    pub mod __idl {
        use super::*;
        #[inline(never)]
        #[cfg(not(feature = "no-idl"))]
        pub fn __idl_dispatch(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            idl_ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            let mut accounts = accounts;
            let mut data: &[u8] = idl_ix_data;
            let ix = anchor_lang::idl::IdlInstruction::deserialize(&mut data)
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            match ix {
                anchor_lang::idl::IdlInstruction::Create { data_len } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_account(program_id, &mut accounts, data_len)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::CreateBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlCreateBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_create_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::Write { data } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_write(program_id, &mut accounts, data)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetAuthority { new_authority } => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlAccounts::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_authority(program_id, &mut accounts, new_authority)?;
                    accounts.exit(program_id)?;
                }
                anchor_lang::idl::IdlInstruction::SetBuffer => {
                    let mut bumps = std::collections::BTreeMap::new();
                    let mut reallocs = std::collections::BTreeSet::new();
                    let mut accounts = anchor_lang::idl::IdlSetBuffer::try_accounts(
                        program_id,
                        &mut accounts,
                        &[],
                        &mut bumps,
                        &mut reallocs,
                    )?;
                    __idl_set_buffer(program_id, &mut accounts)?;
                    accounts.exit(program_id)?;
                }
            }
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_account(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateAccounts,
            data_len: u64,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateAccount");
            if program_id != accounts.program.key {
                return Err(
                    anchor_lang::error::ErrorCode::IdlInstructionInvalidProgram.into(),
                );
            }
            let from = accounts.from.key;
            let (base, nonce) = Pubkey::find_program_address(&[], program_id);
            let seed = anchor_lang::idl::IdlAccount::seed();
            let owner = accounts.program.key;
            let to = Pubkey::create_with_seed(&base, seed, owner).unwrap();
            let space = 8 + 32 + 4 + data_len as usize;
            let rent = Rent::get()?;
            let lamports = rent.minimum_balance(space);
            let seeds = &[&[nonce][..]];
            let ix = anchor_lang::solana_program::system_instruction::create_account_with_seed(
                from,
                &to,
                &base,
                seed,
                lamports,
                space as u64,
                owner,
            );
            anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &[
                    accounts.from.clone(),
                    accounts.to.clone(),
                    accounts.base.clone(),
                    accounts.system_program.clone(),
                ],
                &[seeds],
            )?;
            let mut idl_account = {
                let mut account_data = accounts.to.try_borrow_data()?;
                let mut account_data_slice: &[u8] = &account_data;
                anchor_lang::idl::IdlAccount::try_deserialize_unchecked(
                    &mut account_data_slice,
                )?
            };
            idl_account.authority = *accounts.from.key;
            let mut data = accounts.to.try_borrow_mut_data()?;
            let dst: &mut [u8] = &mut data;
            let mut cursor = std::io::Cursor::new(dst);
            idl_account.try_serialize(&mut cursor)?;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_create_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlCreateBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlCreateBuffer");
            let mut buffer = &mut accounts.buffer;
            buffer.authority = *accounts.authority.key;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_write(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            idl_data: Vec<u8>,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlWrite");
            let mut idl = &mut accounts.idl;
            idl.data.extend(idl_data);
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_authority(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlAccounts,
            new_authority: Pubkey,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetAuthority");
            accounts.idl.authority = new_authority;
            Ok(())
        }
        #[inline(never)]
        pub fn __idl_set_buffer(
            program_id: &Pubkey,
            accounts: &mut anchor_lang::idl::IdlSetBuffer,
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: IdlSetBuffer");
            accounts.idl.data = accounts.buffer.data.clone();
            Ok(())
        }
    }
    /// __state mod defines wrapped handlers for state instructions.
    pub mod __state {
        use super::*;
    }
    /// __interface mod defines wrapped handlers for `#[interface]` trait
    /// implementations.
    pub mod __interface {
        use super::*;
    }
    /// __global mod defines wrapped handlers for global instructions.
    pub mod __global {
        use super::*;
        #[inline(never)]
        pub fn orca_whirlpool_swap(
            program_id: &Pubkey,
            accounts: &[AccountInfo],
            ix_data: &[u8],
        ) -> anchor_lang::Result<()> {
            ::solana_program::log::sol_log("Instruction: OrcaWhirlpoolSwap");
            let ix = instruction::OrcaWhirlpoolSwap::deserialize(&mut &ix_data[..])
                .map_err(|_| {
                    anchor_lang::error::ErrorCode::InstructionDidNotDeserialize
                })?;
            let instruction::OrcaWhirlpoolSwap { amount, a_to_b } = ix;
            let mut __bumps = std::collections::BTreeMap::new();
            let mut __reallocs = std::collections::BTreeSet::new();
            let mut remaining_accounts: &[AccountInfo] = accounts;
            let mut accounts = OrcaWhirlpoolSwap::try_accounts(
                program_id,
                &mut remaining_accounts,
                ix_data,
                &mut __bumps,
                &mut __reallocs,
            )?;
            let result = swap::orca_whirlpool_swap(
                anchor_lang::context::Context::new(
                    program_id,
                    &mut accounts,
                    remaining_accounts,
                    __bumps,
                ),
                amount,
                a_to_b,
            )?;
            anchor_lang::solana_program::program::set_return_data(
                &result.try_to_vec().unwrap(),
            );
            accounts.exit(program_id)
        }
    }
}
pub mod swap {
    use super::*;
    pub fn orca_whirlpool_swap<'info>(
        ctx: Context<'_, '_, '_, 'info, OrcaWhirlpoolSwap<'info>>,
        amount: u64,
        a_to_b: bool,
    ) -> Result<clockwork_sdk::state::ThreadResponse> {
        orca_whirlpool_swap::handler(ctx, amount, a_to_b)
    }
}
/// An Anchor generated module containing the program's set of
/// instructions, where each method handler in the `#[program]` mod is
/// associated with a struct defining the input arguments to the
/// method. These should be used directly, when one wants to serialize
/// Anchor instruction data, for example, when speciying
/// instructions on a client.
pub mod instruction {
    use super::*;
    /// Instruction struct definitions for `#[state]` methods.
    pub mod state {
        use super::*;
    }
    /// Instruction.
    pub struct OrcaWhirlpoolSwap {
        pub amount: u64,
        pub a_to_b: bool,
    }
    impl borsh::ser::BorshSerialize for OrcaWhirlpoolSwap
    where
        u64: borsh::ser::BorshSerialize,
        bool: borsh::ser::BorshSerialize,
    {
        fn serialize<W: borsh::maybestd::io::Write>(
            &self,
            writer: &mut W,
        ) -> ::core::result::Result<(), borsh::maybestd::io::Error> {
            borsh::BorshSerialize::serialize(&self.amount, writer)?;
            borsh::BorshSerialize::serialize(&self.a_to_b, writer)?;
            Ok(())
        }
    }
    impl borsh::de::BorshDeserialize for OrcaWhirlpoolSwap
    where
        u64: borsh::BorshDeserialize,
        bool: borsh::BorshDeserialize,
    {
        fn deserialize(
            buf: &mut &[u8],
        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
            Ok(Self {
                amount: borsh::BorshDeserialize::deserialize(buf)?,
                a_to_b: borsh::BorshDeserialize::deserialize(buf)?,
            })
        }
    }
    impl anchor_lang::Discriminator for OrcaWhirlpoolSwap {
        const DISCRIMINATOR: [u8; 8] = [79, 43, 112, 12, 131, 182, 81, 216];
    }
    impl anchor_lang::InstructionData for OrcaWhirlpoolSwap {}
    impl anchor_lang::Owner for OrcaWhirlpoolSwap {
        fn owner() -> Pubkey {
            ID
        }
    }
}
#[cfg(feature = "cpi")]
pub mod cpi {
    use super::*;
    use std::marker::PhantomData;
    pub mod state {
        use super::*;
    }
    pub struct Return<T> {
        phantom: std::marker::PhantomData<T>,
    }
    impl<T: AnchorDeserialize> Return<T> {
        pub fn get(&self) -> T {
            let (_key, data) = anchor_lang::solana_program::program::get_return_data()
                .unwrap();
            T::try_from_slice(&data).unwrap()
        }
    }
    pub fn orca_whirlpool_swap<'a, 'b, 'c, 'info>(
        ctx: anchor_lang::context::CpiContext<
            'a,
            'b,
            'c,
            'info,
            crate::cpi::accounts::OrcaWhirlpoolSwap<'info>,
        >,
        amount: u64,
        a_to_b: bool,
    ) -> anchor_lang::Result<crate::cpi::Return<clockwork_sdk::state::ThreadResponse>> {
        let ix = {
            let ix = instruction::OrcaWhirlpoolSwap {
                amount,
                a_to_b,
            };
            let mut ix_data = AnchorSerialize::try_to_vec(&ix)
                .map_err(|_| anchor_lang::error::ErrorCode::InstructionDidNotSerialize)?;
            let mut data = [79, 43, 112, 12, 131, 182, 81, 216].to_vec();
            data.append(&mut ix_data);
            let accounts = ctx.to_account_metas(None);
            anchor_lang::solana_program::instruction::Instruction {
                program_id: crate::ID,
                accounts,
                data,
            }
        };
        let mut acc_infos = ctx.to_account_infos();
        anchor_lang::solana_program::program::invoke_signed(
                &ix,
                &acc_infos,
                ctx.signer_seeds,
            )
            .map_or_else(
                |e| Err(Into::into(e)),
                |_| {
                    Ok(crate::cpi::Return::<clockwork_sdk::state::ThreadResponse> {
                        phantom: crate::cpi::PhantomData,
                    })
                },
            )
    }
    /// An Anchor generated module, providing a set of structs
    /// mirroring the structs deriving `Accounts`, where each field is
    /// an `AccountInfo`. This is useful for CPI.
    pub mod accounts {
        pub use crate::__cpi_client_accounts_orca_whirlpool_swap::*;
    }
}
/// An Anchor generated module, providing a set of structs
/// mirroring the structs deriving `Accounts`, where each field is
/// a `Pubkey`. This is useful for specifying accounts for a client.
pub mod accounts {
    pub use crate::__client_accounts_orca_whirlpool_swap::*;
}
